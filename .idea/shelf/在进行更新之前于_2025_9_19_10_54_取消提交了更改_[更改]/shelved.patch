Index: generator/generator.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package generator\n\nimport (\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"crypto/md5\"\n\t\"fmt\"\n\t\"io\"\n\n\t\"github.com/lefeck/autouiso/cmd\"\n\t\"github.com/lefeck/autouiso/logger\"\n\t\"github.com/lefeck/autouiso/utils\"\n\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"text/template\"\n\t\"time\"\n)\n\nfunc (p Package) String() string {\n\treturn string(p)\n}\n\n// PackageInfo describes required system packages and the primary command to check.\ntype PackageInfo struct {\n\tPackages []string // System package names\n\tCommand  string   // Provided command used to check existence\n}\n\ntype Package string\n\nconst (\n\tPackageXorriso  Package = \"xorriso\"\n\tPackageSed      Package = \"sed\"\n\tPackageCurl     Package = \"curl\"\n\tPackageGpg      Package = \"gpg\"\n\tPackage7z       Package = \"7z\"\n\tPackageDpkgDev  Package = \"dpkg-dev\"\n\tPackageAptitude Package = \"aptitude\"\n)\n\nvar packages = map[Package]PackageInfo{\n\tPackageXorriso: {\n\t\tPackages: []string{\"xorriso\", \"isolinux\", \"binutils\", \"fakeroot\"},\n\t\tCommand:  \"xorriso\",\n\t},\n\tPackageSed: {\n\t\tPackages: []string{\"sed\"},\n\t\tCommand:  \"sed\",\n\t},\n\tPackageCurl: {\n\t\tPackages: []string{\"curl\"},\n\t\tCommand:  \"curl\",\n\t},\n\tPackageGpg: {\n\t\tPackages: []string{\"gpg\"},\n\t\tCommand:  \"gpg\",\n\t},\n\tPackage7z: {\n\t\tPackages: []string{\"p7zip-full\"},\n\t\tCommand:  \"7z\",\n\t},\n\tPackageDpkgDev: {\n\t\tPackages: []string{\"dpkg-dev\"},\n\t\tCommand:  \"dpkg-scanpackages\",\n\t},\n\tPackageAptitude: {\n\t\tPackages: []string{\"aptitude\"},\n\t\tCommand:  \"aptitude\",\n\t},\n}\n\n// Generator orchestrates the ISO build workflow.\ntype Generator struct {\n\texecutor *cmd.Executor\n\tPath     *utils.Path\n}\n\n// NewGenerator creates a Generator and prepares base directories.\n// NewGenerator constructs a Generator and ensures base directories exist.\nfunc NewGenerator(executor *cmd.Executor, rootDir string) (*Generator, error) {\n\tpath := utils.NewPath(rootDir)\n\t// Prepare base directories\n\tdirs := []string{\n\t\trootDir,\n\t\tpath.DownloadDir(),\n\t\tpath.BuildDir(),\n\t\tpath.Mount(),\n\t\tpath.Packages(),\n\t\tpath.Scripts(),\n\t}\n\n\t// Create directories if not present\n\tfor _, dir := range dirs {\n\t\tif err := os.MkdirAll(dir, DefaultDirPerm); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to create directory %s: %w\", dir, err)\n\t\t}\n\t}\n\tlogger.Infof(\"Using temporary directory: %s\", rootDir)\n\treturn &Generator{\n\t\texecutor: executor,\n\t\tPath:     path,\n\t}, nil\n}\n\n// isExistPackage checks if a package/command exists.\nfunc (g *Generator) isExistPackage(command string) bool {\n\t_, err := exec.LookPath(command)\n\treturn err == nil\n}\n\n// CheckNetwork checks network connection.\nfunc (g *Generator) checkNetwork() error {\n\tlogger.Info(\"Checking network connectivity...\")\n\t_, _, err := g.executor.RunCmdWithAttempts(PingCmdTemplate, 3, 5*time.Second)\n\tif err != nil {\n\t\tlogger.Errorf(\"Network connectivity check failed: %v\", err)\n\t\treturn fmt.Errorf(\"network connectivity check failed: %v\", err)\n\t}\n\tlogger.Info(\"Network connection is active\")\n\treturn nil\n}\n\nfunc (g *Generator) updateSource() error {\n\tlogger.Info(\"Updating package list...\")\n\t_, _, err := g.executor.RunCmdWithAttempts(AptUpdateCmdTemplate, 3, 5*time.Second)\n\tif err != nil {\n\t\tlogger.Errorf(\"Failed to update package list: %v\", err)\n\t\treturn fmt.Errorf(\"Failed to update package list: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (g *Generator) ensurePackagesInstalled(pkg Package) error {\n\tinfo, ok := packages[pkg]\n\tif !ok {\n\t\treturn fmt.Errorf(\"package %s not found\", pkg)\n\t}\n\tif g.isExistPackage(info.Command) {\n\t\tlogger.Infof(\"Command %s already exists, skip installation\", info.Command)\n\t\treturn nil\n\t}\n\n\tlogger.Infof(\"Command %s not found, attempting to install\", info.Command)\n\n\tif err := g.updateSource(); err != nil {\n\t\treturn err\n\t}\n\n\tif err := g.checkNetwork(); err != nil {\n\t\treturn err\n\t}\n\n\tvar pkgs []string\n\tfor _, name := range info.Packages {\n\t\tpkgs = append(pkgs, name)\n\t}\n\tif len(pkgs) > 0 {\n\t\tif err := g.installPackages(strings.Join(pkgs, \" \")); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (g *Generator) installPackages(pkgs string) error {\n\tlogger.Infof(\"Installing packages: %s\", pkgs)\n\taptCmd := fmt.Sprintf(AptCmdTemplate, pkgs)\n\t_, _, err := g.executor.RunCmdWithAttempts(aptCmd, 3, 5*time.Second)\n\tif err != nil {\n\t\tlogger.Errorf(\"Package installation failed for %s: %v\", pkgs, err)\n\t\treturn fmt.Errorf(\"installation of package %s failed: %v\", pkgs, err)\n\t}\n\n\tlogger.Infof(\"Successfully installed packages: %s\", pkgs)\n\treturn nil\n}\n\n// CheckPackages checks and installs necessary packages.\nfunc (g *Generator) checkPackages(codename string) error {\n\tpkgs := []Package{\n\t\tPackageXorriso,\n\t\tPackageSed,\n\t\tPackageCurl,\n\t\tPackageGpg,\n\t\tPackage7z,\n\t\tPackageDpkgDev,\n\t\tPackageAptitude,\n\t}\n\tfor _, pkg := range pkgs {\n\t\tif err := g.ensurePackagesInstalled(pkg); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t// Special check for focal release, like shell.\n\tif codename == \"focal\" {\n\t\tif _, err := os.Stat(ISOhdpfxPath); os.IsNotExist(err) {\n\t\t\treturn fmt.Errorf(\"isolinux is not installed. On Ubuntu, install the 'isolinux' package\")\n\t\t}\n\t}\n\tlogger.Info(\"All necessary packages are installed successfully\")\n\treturn nil\n}\n\n// Preprocess combines creation and checks, similar to original shell.\nfunc (g *Generator) Preprocess(codename string) error {\n\treturn g.checkPackages(codename)\n}\n\n// PrepareEnvironment ensures required system packages are installed. Wrapper for Preprocess.\nfunc (g *Generator) PrepareEnvironment(codename string) error {\n\treturn g.Preprocess(codename)\n}\n\n// buildDownloadURL builds the Ubuntu release URL for the given codename.\nfunc (g *Generator) buildDownloadURL(codename string) string {\n\treturn DownloadURL + codename\n}\n\n// DownloadImage downloads the Ubuntu ISO page, resolves the filename and fetches the ISO.\nfunc (gen *Generator) DownloadImage(codename string, gpgVerify bool) (imagepath string, err error) {\n\turl := gen.buildDownloadURL(codename)\n\tlogger.Info(\"Checking for current release...\")\n\n\t// Fetch release page and extract ISO filename\n\tlogger.Infof(\"Fetching download page for Ubuntu %s...\", codename)\n\tcurlCmdTemplate := fmt.Sprintf(CurlCmdTemplate, codename)\n\tstdout, _, err := gen.executor.RunCmd(curlCmdTemplate)\n\tif err != nil {\n\t\tlogger.Errorf(\"Failed to fetch download page: %v\", err)\n\t\treturn \"\", fmt.Errorf(\"failed to fetch download page: %w\", err)\n\t}\n\n\tre := regexp.MustCompile(RegexISOName)\n\tmatches := re.FindStringSubmatch(stdout)\n\tif len(matches) == 0 {\n\t\treturn \"\", fmt.Errorf(\"no ISO file found on the download page\")\n\t}\n\tfileName := matches[0] // 22.04.5-live-server-amd64.iso\n\n\timagePath := gen.Path.DownloadFile(fileName) // /tmp/downloads/ubuntu-22.04.5-live-server-amd64.iso\n\n\tversion := strings.SplitN(fileName, \"-\", 2)[1] // 22.04.5\n\n\t// Download if not exists, otherwise reuse local file\n\tif _, err := os.Stat(imagePath); os.IsNotExist(err) {\n\t\tlogger.Infof(\"Downloading ISO image for Ubuntu %s %s...\", version, codename)\n\t\tdownloadURL := fmt.Sprintf(\"%s/%s\", url, fileName)\n\t\tif err := utils.DownloadFile(downloadURL, imagePath); err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"failed to download ISO: %w\", err)\n\t\t}\n\t\tlogger.Infof(\"Downloaded and saved to %s\", imagePath)\n\t} else {\n\t\tlogger.Infof(\"Using existing %s file\", imagePath)\n\t\tif gpgVerify {\n\t\t\tdownloadDir := gen.Path.DownloadDir()\n\t\t\tif imagePath != filepath.Join(downloadDir, fileName) {\n\t\t\t\tlogger.Warn(\"Automatic GPG verification is enabled. If the source ISO file is not the latest daily or release image, verification will fail!\")\n\t\t\t}\n\t\t}\n\t}\n\treturn imagePath, nil\n}\n\n// DownloadISOImage is a clearer alias for DownloadImage.\nfunc (gen *Generator) DownloadISOImage(codename string, gpgVerify bool) (string, error) {\n\treturn gen.DownloadImage(codename, gpgVerify)\n}\n\n// VerifyISO verifies ISO using downloaded SHA256SUMS and Ubuntu signing keys.\nfunc (gen *Generator) VerifyISO(gpgVerify bool, sourceISO string, codename string) error {\n\tif !gpgVerify {\n\t\tlogger.Info(\"Skipping verification of source ISO\")\n\t\treturn nil\n\t}\n\n\tshaSuffix := time.Now().Format(\"20060102150405\")\n\tshaSumsFile := gen.Path.Sha256SumsFile(shaSuffix)\n\tshaSumsGPGFile := gen.Path.Sha256SumsGPGFile(shaSuffix)\n\tkeyringFile := gen.Path.KeyringFile(UbuntuGPGKeyID)\n\n\t// Build base URL for the selected codename\n\tbaseURL := gen.buildDownloadURL(codename)\n\n\t// Download SHA256SUMS and SHA256SUMS.gpg\n\tif err := gen.downloadSHA256Files(baseURL, shaSumsFile, shaSumsGPGFile); err != nil {\n\t\treturn err\n\t}\n\n\t// Download Ubuntu signing key (to custom keyring)\n\tif err := gen.downloadSigningKey(keyringFile); err != nil {\n\t\treturn err\n\t}\n\n\t// Verify GPG signature for SHA256SUMS file\n\tif err := gen.verifyGPGSignature(keyringFile, shaSumsGPGFile, shaSumsFile); err != nil {\n\t\treturn err\n\t}\n\n\t// Compute SHA256 for the ISO file\n\tdigest, err := utils.CalculateSHA256(sourceISO)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to calculate SHA256 digest: %w\", err)\n\t}\n\n\t// Validate SHA256 against SHA256SUMS\n\tif err := gen.verifySHA256Checksum(shaSumsFile, digest); err != nil {\n\t\treturn err\n\t}\n\n\tlogger.Info(\"Verification succeeded\")\n\treturn nil\n}\n\n// downloadSHA256Files downloads SHA256SUMS and SHA256SUMS.gpg to the download directory.\nfunc (g *Generator) downloadSHA256Files(baseURL, shaSumsFile, shaSumsGPGFile string) error {\n\tif _, err := os.Stat(shaSumsFile); os.IsNotExist(err) {\n\t\tlogger.Info(\"Downloading SHA256SUMS & SHA256SUMS.gpg files...\")\n\t\t// Must use the same directory as ISO\n\t\tlogger.Infof(\"Downloading SHA256SUMS from: %s/SHA256SUMS\", baseURL)\n\t\tif err := utils.DownloadFile(fmt.Sprintf(\"%s/SHA256SUMS\", baseURL), shaSumsFile); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to download SHA256SUMS: %w\", err)\n\t\t}\n\t\tlogger.Infof(\"Downloading SHA256SUMS.gpg from: %s/SHA256SUMS.gpg\", baseURL)\n\t\tif err := utils.DownloadFile(fmt.Sprintf(\"%s/SHA256SUMS.gpg\", baseURL), shaSumsGPGFile); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to download SHA256SUMS.gpg: %w\", err)\n\t\t}\n\t} else {\n\t\tlogger.Infof(\"Using existing SHA256SUMS & SHA256SUMS.gpg files\")\n\t}\n\treturn nil\n}\n\n// downloadSigningKey downloads the Ubuntu signing key to a local keyring file.\nfunc (g *Generator) downloadSigningKey(keyringFile string) error {\n\tif _, err := os.Stat(keyringFile); os.IsNotExist(err) {\n\t\tlogger.Info(\"Downloading and saving Ubuntu signing key...\")\n\t\tgpgRecvKeyCmdTemplate := fmt.Sprintf(GpgRecvKeyCmdTemplate, keyringFile, UbuntuGPGKeyID)\n\t\t_, _, err := g.executor.RunCmdWithAttempts(gpgRecvKeyCmdTemplate, 3, 5)\n\t\tif err != nil {\n\t\t\tlogger.Errorf(\"Failed to download Ubuntu signing key: %v\", err)\n\t\t\treturn fmt.Errorf(\"failed to download Ubuntu signing key: %w\", err)\n\t\t}\n\t\tlogger.Infof(\"Successfully downloaded and saved Ubuntu signing key to %s\", keyringFile)\n\t} else {\n\t\tlogger.Infof(\"Using existing Ubuntu signing key saved in %s\", keyringFile)\n\t}\n\treturn nil\n}\n\n// verifyGPGSignature verifies the SHA256SUMS.gpg signature against the keyring.\nfunc (g *Generator) verifyGPGSignature(keyringFile, shaSumsGPGFile, shaSumsFile string) error {\n\tlogger.Infof(\"Verifying integrity and authenticity...\")\n\tlogger.Infof(\"GPG command: gpg --keyring %s --verify %s %s\", keyringFile, shaSumsGPGFile, shaSumsFile)\n\n\t// Ensure required files exist\n\tif _, err := os.Stat(keyringFile); os.IsNotExist(err) {\n\t\treturn fmt.Errorf(\"keyring file not found: %s\", keyringFile)\n\t}\n\tif _, err := os.Stat(shaSumsGPGFile); os.IsNotExist(err) {\n\t\treturn fmt.Errorf(\"SHA256SUMS.gpg file not found: %s\", shaSumsGPGFile)\n\t}\n\tif _, err := os.Stat(shaSumsFile); os.IsNotExist(err) {\n\t\treturn fmt.Errorf(\"SHA256SUMS file not found: %s\", shaSumsFile)\n\t}\n\n\tgpgVerifyCmdTemplate := fmt.Sprintf(GpgVerifyCmdTemplate, keyringFile, shaSumsGPGFile, shaSumsFile)\n\t_, stderr, err := g.executor.RunCmd(gpgVerifyCmdTemplate)\n\tif err != nil {\n\t\tlogger.Errorf(\"GPG signature verification failed: %v\", err)\n\t\tlogger.Errorf(\"GPG stderr output: %s\", stderr)\n\t\t// Clean temporary keyring if present\n\t\ttempKeyringFile := fmt.Sprintf(\"%s~\", keyringFile)\n\t\tif _, statErr := os.Stat(tempKeyringFile); statErr == nil {\n\t\t\tif rmErr := os.Remove(tempKeyringFile); rmErr != nil {\n\t\t\t\tlogger.Warnf(\"Failed to remove temporary keyring file %s: %v\", tempKeyringFile, rmErr)\n\t\t\t}\n\t\t}\n\t\treturn fmt.Errorf(\"verification of SHA256SUMS signature failed: %v, stderr: %s\", err, stderr)\n\t}\n\n\tlogger.Info(\"GPG signature verification completed successfully\")\n\n\t// Clean temporary keyring if present\n\ttempKeyringFile := fmt.Sprintf(\"%s~\", keyringFile)\n\tif _, statErr := os.Stat(tempKeyringFile); statErr == nil {\n\t\tif rmErr := os.Remove(tempKeyringFile); rmErr != nil {\n\t\t\tlogger.Warnf(\"Failed to remove temporary keyring file %s: %v\", tempKeyringFile, rmErr)\n\t\t}\n\t}\n\treturn nil\n}\n\n// verifySHA256Checksum checks if a SHA256 digest exists within SHA256SUMS.\nfunc (g *Generator) verifySHA256Checksum(shaSumsFile, digest string) error {\n\tshaSums, err := os.ReadFile(shaSumsFile)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to read SHA256SUMS file: %w\", err)\n\t}\n\tif !bytes.Contains(shaSums, []byte(digest)) {\n\t\treturn fmt.Errorf(\"verification of ISO digest failed\")\n\t}\n\treturn nil\n}\n\n// ISO extraction\n\n// ExtractISO extracts ISO contents into the build directory and fixes permissions.\nfunc (gen *Generator) ExtractISO(codename string, sourceISO string) error {\n\tboot := gen.Path.Boot()\n\n\tlogger.Info(\"Extracting ISO image...\")\n\n\t// Choose extractor by codename\n\tif err := gen.extractISOImage(codename, sourceISO); err != nil {\n\t\treturn err\n\t}\n\t// Cleanup and move boot artifacts\n\tif err := gen.cleanupAndMoveFiles(codename, boot); err != nil {\n\t\treturn err\n\t}\n\t// Fix permissions under build dir\n\tif err := gen.adjustPermissions(); err != nil {\n\t\treturn err\n\t}\n\n\tlogger.Infof(\"Extracted to %s\", gen.Path.BuildDir())\n\treturn nil\n}\n\n// extractISOImage selects xorriso or 7z to extract based on codename.\nfunc (g *Generator) extractISOImage(codename string, sourceISO string) error {\n\tbuidDir := g.Path.BuildDir()\n\tswitch codename {\n\tcase \"focal\":\n\t\tlogger.Info(\"Extracting ISO using xorriso...\")\n\t\txorrisoCmd := fmt.Sprintf(XorrisoCmdTemplate, sourceISO, buidDir)\n\t\t_, _, err := g.executor.RunCmd(xorrisoCmd)\n\t\tif err != nil {\n\t\t\tlogger.Errorf(\"Failed to extract ISO using xorriso: %v\", err)\n\t\t\treturn fmt.Errorf(\"failed to extract ISO image using xorriso: %w\", err)\n\t\t}\n\t\tlogger.Info(\"Successfully extracted ISO using xorriso\")\n\tdefault:\n\t\tlogger.Info(\"Extracting ISO using 7z...\")\n\t\ts7zCmd := fmt.Sprintf(S7zCmdTemplate, sourceISO, buidDir)\n\t\t_, _, err := g.executor.RunCmd(s7zCmd)\n\t\tif err != nil {\n\t\t\tlogger.Errorf(\"Failed to extract ISO using 7z: %v\", err)\n\t\t\treturn fmt.Errorf(\"failed to extract ISO image using 7z: %w\", err)\n\t\t}\n\t\tlogger.Info(\"Successfully extracted ISO using 7z\")\n\t}\n\treturn nil\n}\n\n// cleanupAndMoveFiles removes unwanted dirs and moves [BOOT] to BOOT when required.\nfunc (gen *Generator) cleanupAndMoveFiles(codename string, boot string) error {\n\tbootISO := gen.Path.BootISO()\n\tswitch codename {\n\tcase \"focal\":\n\t\tif err := os.RemoveAll(bootISO); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to remove [BOOT] directory: %w\", err)\n\t\t}\n\tdefault:\n\t\t// Remove existing boot dir if present\n\t\tif _, err := os.Stat(boot); err == nil {\n\t\t\tif err := os.RemoveAll(boot); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to remove bootdir: %w\", err)\n\t\t\t}\n\t\t}\n\t\tif _, err := os.Stat(bootISO); !os.IsNotExist(err) {\n\t\t\tlogger.Infof(\"Moving [BOOT] from %s to %s\", bootISO, boot)\n\t\t\tif err := os.Rename(bootISO, boot); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to move [BOOT] to bootDir: %w\", err)\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// adjustPermissions sets DefaultDirPerm recursively for build dir.\nfunc (gen *Generator) adjustPermissions() error {\n\tbuildDir := gen.Path.BuildDir()\n\tif err := os.Chmod(buildDir, DefaultDirPerm); err != nil {\n\t\treturn fmt.Errorf(\"failed to change permissions of tmpDir: %w\", err)\n\t}\n\tif err := filepath.Walk(buildDir, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn os.Chmod(path, DefaultDirPerm)\n\t}); err != nil {\n\t\treturn fmt.Errorf(\"failed to recursively change permissions: %w\", err)\n\t}\n\treturn nil\n}\n\n// RepackageISOImage rebuilds ISO using xorriso templates appropriate for codename.\nfunc (gen *Generator) RepackageISOImage(codename string, destinationISO string) error {\n\tlogger.Info(\"Repackaging extracted files into an ISO image...\")\n\n\t// Ensure destination has .iso extension\n\tif filepath.Ext(destinationISO) != \".iso\" {\n\t\treturn fmt.Errorf(\"verification of iso image format failed\")\n\t}\n\n\tbuildDir := gen.Path.BuildDir()\n\t// Change into build directory while running xorriso\n\trestore, err := changeDir(buildDir)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer restore()\n\n\tdestinationISOFile := gen.Path.DownloadFile(destinationISO)\n\t// Generate final ISO label\n\tisoName, err := gen.generateISOName(codename)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to generate ISO name: %w\", err)\n\t}\n\n\t// Build xorriso command from templates\n\tcmdStr, err := gen.buildXorrisoCommand(codename, isoName, destinationISOFile)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to build xorriso command: %w\", err)\n\t}\n\n\t// Execute xorriso\n\tlogger.Info(\"Executing xorriso to create final ISO...\")\n\t_, _, err = gen.executor.RunCmd(cmdStr)\n\tif err != nil {\n\t\tlogger.Errorf(\"xorriso command failed: %v\", err)\n\t\treturn err\n\t}\n\n\tlogger.Infof(\"Successfully repackaged into ISO: %s\", destinationISO)\n\treturn nil\n}\n\n// generateISOName generates the ISO name based on the codename.\nfunc (gen *Generator) generateISOName(codename string) (string, error) {\n\tvar isoName bytes.Buffer\n\tdata := map[string]string{\"codename\": codename}\n\tif err := NameTemplate.Execute(&isoName, data); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn isoName.String(), nil\n}\n\n// buildXorrisoCommand builds the xorriso command based on the codename.\nfunc (gen *Generator) buildXorrisoCommand(codename, isoName, destinationISOFile string) (string, error) {\n\tvar cmdBuilder bytes.Buffer\n\tdata := map[string]string{\n\t\t\"Label\":  isoName,\n\t\t\"Output\": destinationISOFile,\n\t}\n\n\tvar tmpl *template.Template\n\tif codename == \"focal\" {\n\t\ttmpl = XorrisoCmdUbuntu2004Template\n\t} else {\n\t\ttmpl = XorrisoCmdUbuntu2204Template\n\t}\n\n\tif err := tmpl.Execute(&cmdBuilder, data); err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn cmdBuilder.String(), nil\n}\n\n// CleanUp deletes the build directory tree.\nfunc (gen *Generator) CleanUp() error {\n\tbuildDir := gen.Path.BuildDir()\n\tif err := os.RemoveAll(buildDir); err != nil {\n\t\tlogger.Warnf(\"Failed to clean up temporary directory %s: %v\", buildDir, err)\n\t\treturn fmt.Errorf(\"Failed to clean up temporary directory: %v\", err)\n\t}\n\tlogger.Infof(\"Successfully cleaned up temporary directory: %s\", buildDir)\n\treturn nil\n}\n\n// AddConfigData adds meta-data file and updates GRUB/txt configs to use NoCloud datasource.\nfunc (gen *Generator) AddConfigData(codename string) error {\n\tbuildDir := gen.Path.BuildDir()\n\tlogger.Info(\"Adding user-data and meta-data files...\")\n\n\t// Create empty meta-data file\n\tif err := touchFile(filepath.Join(buildDir, MetaDataFile)); err != nil {\n\t\treturn fmt.Errorf(\"failed to create meta-data: %w\", err)\n\t}\n\n\t// Update GRUB config\n\tgrubCfgPath := filepath.Join(buildDir, GrubConfigPath)\n\tif err := modifyGrubConfig(grubCfgPath); err != nil {\n\t\treturn fmt.Errorf(\"failed to modify grub.cfg: %w\", err)\n\t}\n\n\t// For focal, also update txt.cfg and loopback.cfg\n\tif codename == \"focal\" {\n\t\ttxtCfgPath := filepath.Join(buildDir, TxtConfigPath)\n\t\tif err := modifyGrubConfig(txtCfgPath); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to modify txt.cfg: %w\", err)\n\t\t}\n\t\tloopbackCfgPath := filepath.Join(buildDir, LoopBackConfigPath)\n\t\tif err := modifyGrubConfig(loopbackCfgPath); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to modify loopback.cfg: %w\", err)\n\t\t}\n\t}\n\tlogger.Info(\"Added data and configured kernel command line\")\n\treturn nil\n}\n\n// InjectNoCloudConfig is an alias for AddConfigData.\nfunc (gen *Generator) InjectNoCloudConfig(codename string) error {\n\treturn gen.AddConfigData(codename)\n}\n\n// DownloadAndPreparePackages downloads packages, builds a local repo and creates install script.\nfunc (g *Generator) DownloadAndPreparePackages(packages []string) error {\n\tif len(packages) == 0 {\n\t\treturn nil\n\t}\n\tlogger.Info(\"Adding config-data files...\")\n\n\t// Normalize package names list\n\tpkgs, err := g.parsePackageFile(packages)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Download packages\n\tif err := g.downloadPackages(pkgs); err != nil {\n\t\treturn err\n\t}\n\n\t// Build local repo index files (Packages/Packages.gz)\n\tif err := g.generateLocalRepoIndex(); err != nil {\n\t\treturn err\n\t}\n\tlogger.Info(\"Building local dependency packages\")\n\n\t// Create installation script\n\tif err := g.createInstallationScript(pkgs); err != nil {\n\t\treturn err\n\t}\n\tlogger.Info(\"Building local dependency packages to write script automatic execution\")\n\n\treturn nil\n}\n\n// PrepareLocalPackagesRepo is an alias for DownloadAndPreparePackages.\nfunc (g *Generator) PrepareLocalPackagesRepo(packages []string) error {\n\treturn g.DownloadAndPreparePackages(packages)\n}\n\n// parsePackageFile trims whitespace and removes comments/empty lines.\nfunc (gen *Generator) parsePackageFile(packages []string) ([]string, error) {\n\tvar pkgs []string\n\tfor _, line := range packages {\n\t\tline = strings.TrimSpace(line)\n\t\tif line != \"\" && !strings.HasPrefix(line, \"#\") {\n\t\t\tpkgs = append(pkgs, line)\n\t\t}\n\t}\n\treturn pkgs, nil\n}\n\n// downloadPackages downloads all specified packages and moves .deb files.\nfunc (gen *Generator) downloadPackages(packages []string) error {\n\tpkgDir := gen.Path.Packages()\n\tfor _, pkg := range packages {\n\t\tlogger.Infof(\"Downloading and saving packages %s\", pkg)\n\t\tif err := gen.downloadPackage(pkgDir, pkg); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to download package %s: %w\", pkg, err)\n\t\t}\n\t\tlogger.Infof(\"Downloaded and saved all packages to %s/%s\", pkgDir, pkg)\n\t}\n\treturn nil\n}\n\n// generateLocalRepoIndex generates local APT repository index files.\nfunc (gen *Generator) generateLocalRepoIndex() error {\n\n\tif err := gen.buildPackagesIndex(); err != nil {\n\t\treturn fmt.Errorf(\"failed to generate package index: %w\", err)\n\t}\n\treturn nil\n}\n\n// createInstallationScript writes a shell script that installs the packages.\nfunc (gen *Generator) createInstallationScript(packages []string) error {\n\tscriptFile := gen.Path.ScriptFile(ScriptFileName)\n\n\tif err := createInstallScript(scriptFile, packages); err != nil {\n\t\treturn fmt.Errorf(\"failed to create install script: %w\", err)\n\t}\n\n\t// Make script executable\n\tif err := os.Chmod(scriptFile, DefaultDirPerm); err != nil {\n\t\treturn fmt.Errorf(\"failed to set script permissions: %w\", err)\n\t}\n\n\treturn nil\n}\n\nfunc touchFile(path string) error {\n\tf, err := os.Create(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn f.Close()\n}\n\n//func modifyGrubConfig(path string) error {\n//\t// Check if file exists\n//\tif _, err := os.Stat(path); os.IsNotExist(err) {\n//\t\treturn nil // Skip if file does not exist\n//\t} else if err != nil {\n//\t\treturn fmt.Errorf(\"failed to stat file %s: %w\", filepath.Base(path), err)\n//\t}\n//\n//\t// Read file content\n//\tcontent, err := os.ReadFile(path)\n//\tif err != nil {\n//\t\treturn fmt.Errorf(\"failed to read file %s: %w\", filepath.Base(path), err)\n//\t}\n//\n//\t// Split content into lines\n//\tlines := strings.Split(string(content), \"\\n\")\n//\tmodified := false\n//\n//\tfor i, line := range lines {\n//\t\t// Trim whitespace from the beginning to handle leading spaces\n//\t\ttrimmedLine := strings.TrimLeft(line, \" \\t\")\n//\t\tif trimmedLine == \"\" {\n//\t\t\tcontinue\n//\t\t}\n//\n//\t\t// Handle \"append\" or \"linux\" lines ending with \"---\"\n//\t\tif (strings.HasPrefix(trimmedLine, \"append\") || strings.HasPrefix(trimmedLine, \"linux\")) && strings.HasSuffix(line, \"---\") {\n//\t\t\t// Check if autoinstall is already present\n//\t\t\tif !strings.Contains(line, \"autoinstall\") {\n//\t\t\t\t// Remove trailing \"---\" temporarily\n//\t\t\t\tbaseLine := strings.TrimSuffix(line, \"---\")\n//\t\t\t\t// Find the position after \"quiet\"\n//\t\t\t\tparts := strings.Fields(baseLine) // Split into words\n//\t\t\t\tvar newParts []string\n//\t\t\t\tquietFound := false\n//\n//\t\t\t\tfor _, part := range parts {\n//\t\t\t\t\tnewParts = append(newParts, part)\n//\t\t\t\t\tif part == \"quiet\" {\n//\t\t\t\t\t\tquietFound = true\n//\t\t\t\t\t\t// Insert autoinstall params after \"quiet\"\n//\t\t\t\t\t\tnewParts = append(newParts, GrubInsertText)\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\n//\t\t\t\t// If \"quiet\" is not found, append at the end\n//\t\t\t\tif !quietFound && len(parts) > 0 {\n//\t\t\t\t\tnewParts = append(newParts, GrubInsertText)\n//\t\t\t\t}\n//\n//\t\t\t\t// Reconstruct the line with \"---\"\n//\t\t\t\tnewLine := strings.Join(newParts, \" \") + \" ---\"\n//\t\t\t\tlines[i] = newLine\n//\t\t\t\tmodified = true\n//\t\t\t}\n//\t\t}\n//\t}\n//\n//\t// If no modification, return early\n//\tif !modified {\n//\t\treturn nil\n//\t}\n//\n//\t// Join lines back and write to file\n//\tnewContent := []byte(strings.Join(lines, \"\\n\"))\n//\tif err := os.WriteFile(path, newContent, GrubFilePerm); err != nil {\n//\t\treturn fmt.Errorf(\"failed to write file %s: %w\", filepath.Base(path), err)\n//\t}\n//\n//\treturn nil\n//}\n\nfunc patchLine(line string) string {\n\ttrim := strings.TrimSpace(line)\n\n\t// 只处理包含 linux/append/kernel 且包含 quiet 和 --- 的行\n\tif !(strings.Contains(trim, \"linux\") || strings.Contains(trim, \"append\")) {\n\t\treturn line\n\t}\n\tif !strings.Contains(trim, \"quiet\") || !strings.Contains(trim, \"---\") {\n\t\treturn line\n\t}\n\n\t// 已经包含 autoinstall，就不处理\n\tif strings.Contains(trim, \"autoinstall\") {\n\t\treturn line\n\t}\n\n\t// 插入到 quiet 后面\n\tparts := strings.Fields(line)\n\tfor i, p := range parts {\n\t\tif p == \"quiet\" {\n\t\t\tparts[i] = p + \" \" + GrubInsertText\n\t\t\tbreak\n\t\t}\n\t}\n\treturn strings.Join(parts, \" \")\n}\n\nfunc modifyGrubConfig(path string) error {\n\tdata, err := os.ReadFile(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlines := strings.Split(string(data), \"\\n\")\n\tfor i, line := range lines {\n\t\tlines[i] = patchLine(line)\n\t}\n\treturn os.WriteFile(path, []byte(strings.Join(lines, \"\\n\")), GrubFilePerm)\n}\n\n// downloadPackage is the main entry for downloading a package and its dependencies\nfunc (g *Generator) downloadPackage(destDir, pkg string) error {\n\t// Step 1: Resolve dependencies\n\tdeps, err := g.resolveDependencies(pkg)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(deps) == 0 {\n\t\tlogger.Warnf(\"No dependencies found for %s\", pkg)\n\t\treturn nil\n\t}\n\n\t// Step 2: Download dependencies\n\tg.downloadDependencies(deps)\n\n\t// Step 3: Move .deb files into the target directory\n\tif err := moveDebFiles(destDir); err != nil {\n\t\treturn fmt.Errorf(\"failed to move deb files for %s: %w\", pkg, err)\n\t}\n\n\treturn nil\n}\n\n// resolveDependencies resolves package dependencies using apt-cache, and falls back to aptitude if needed.\nfunc (g *Generator) resolveDependencies(pkg string) ([]string, error) {\n\tlogger.Infof(\"Resolving dependencies for package: %s\", pkg)\n\t// Try apt-cache first\n\taptCacheCmd := fmt.Sprintf(AptCacheDependsCmdTemplate, pkg)\n\tout, _, err := g.executor.RunCmd(aptCacheCmd)\n\tif err != nil || strings.TrimSpace(out) == \"\" {\n\t\t// Fallback: aptitude\n\t\tlogger.Infof(\"apt-cache failed, trying aptitude for package: %s\", pkg)\n\t\tfallbackCmd := fmt.Sprintf(AptitudeShowCmd, pkg)\n\t\tout, _, err = g.executor.RunCmd(fallbackCmd)\n\t\tif err != nil {\n\t\t\tlogger.Errorf(\"Failed to resolve dependencies for %s: %v\", pkg, err)\n\t\t\treturn nil, fmt.Errorf(\"failed to resolve dependencies for %s: %w\", pkg, err)\n\t\t}\n\t}\n\n\t// Parse and filter dependencies\n\tdeps := filterDependencies(out)\n\tlogger.Infof(\"Resolved %d dependencies for package: %s\", len(deps), pkg)\n\treturn deps, nil\n}\n\n// filterDependencies parses the raw command output and extracts valid dependencies.\nfunc filterDependencies(raw string) []string {\n\tlines := strings.Split(raw, \"\\n\")\n\tvar deps []string\n\tfor _, line := range lines {\n\t\tline = strings.TrimSpace(line)\n\t\tif line == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tif DepLineRegex.MatchString(line) && !strings.Contains(line, ExcludeKeyword) {\n\t\t\tdeps = append(deps, line)\n\t\t}\n\t}\n\treturn deps\n}\n\n// downloadDependencies downloads each dependency using apt-get.\nfunc (g *Generator) downloadDependencies(deps []string) {\n\tlogger.Infof(\"Downloading %d dependencies...\", len(deps))\n\tfor _, dep := range deps {\n\t\tdownloadCmd := fmt.Sprintf(AptGetDownloadCmd, dep)\n\t\t_, _, err := g.executor.RunCmd(downloadCmd)\n\t\tif err != nil {\n\t\t\tlogger.Warnf(\"Failed to download dependency %s: %v\", dep, err)\n\t\t\tcontinue\n\t\t}\n\t\tlogger.Infof(\"Successfully downloaded dependency: %s\", dep)\n\t}\n\tlogger.Info(\"Completed downloading dependencies\")\n}\n\nfunc moveDebFiles(destDir string) error {\n\tfiles, err := filepath.Glob(DebFilePattern)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, file := range files {\n\t\tif err := os.Rename(file, filepath.Join(destDir, filepath.Base(file))); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// ChangeDir  changes the current working directory.\nfunc changeDir(dir string) (func(), error) {\n\tcwd, err := os.Getwd()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"getwd failed: %w\", err)\n\t}\n\n\tif err := os.Chdir(dir); err != nil {\n\t\treturn nil, fmt.Errorf(\"chdir to %s failed: %w\", dir, err)\n\t}\n\n\treturn func() {\n\t\tif err := os.Chdir(cwd); err != nil {\n\t\t\tlogger.Warnf(\"failed to revert to original directory: %v\", err)\n\t\t}\n\t}, nil\n}\n\nfunc (gen *Generator) buildPackagesIndex() error {\n\tlogger.Info(\"Building local package repository index...\")\n\n\t// switch to dir\n\tpackagesDir := gen.Path.Packages()\n\trestore, err := changeDir(packagesDir)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer restore()\n\n\tlogger.Info(\"Running dpkg-scanpackages to generate package index...\")\n\tstdout, _, err := gen.executor.RunCmd(DpkgScanpackagesCmdTemplate)\n\tif err != nil {\n\t\tlogger.Errorf(\"dpkg-scanpackages failed: %v\", err)\n\t\treturn fmt.Errorf(\"dpkg-scanpackages error: %v\", err)\n\t}\n\n\tpkgFile := \"Packages\"\n\tif err = os.WriteFile(pkgFile, []byte(stdout), 0644); err != nil {\n\t\tlogger.Errorf(\"Failed to write Packages file: %v\", err)\n\t\treturn fmt.Errorf(\"write Packages failed: %w\", err)\n\t}\n\n\t// Compress to Packages.gz\n\tlogger.Info(\"Compressing package index to Packages.gz...\")\n\tif err = writeGzip(pkgFile, \"Packages.gz\"); err != nil {\n\t\tlogger.Errorf(\"Failed to compress package index: %v\", err)\n\t\treturn fmt.Errorf(\"gzip failed: %w\", err)\n\t}\n\n\tlogger.Info(\"Successfully built local package repository index\")\n\treturn nil\n}\n\n// writeGzip compresses a file into gzip format.\nfunc writeGzip(src, dst string) error {\n\tdata, err := os.ReadFile(src)\n\tif err != nil {\n\t\treturn err\n\t}\n\tout, err := os.Create(dst)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer out.Close()\n\n\tgw, err := gzip.NewWriterLevel(out, gzip.BestCompression)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif _, err := gw.Write(data); err != nil {\n\t\treturn err\n\t}\n\treturn gw.Close()\n}\n\nfunc createInstallScript(path string, packages []string) error {\n\tt, err := template.New(\"install-script\").Parse(ShellTemplate)\n\tif err != nil {\n\t\treturn err\n\t}\n\tf, err := os.Create(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\treturn t.Execute(f, packages)\n}\n\n// calculateMD5 computes the MD5 checksum of a file.\nfunc calculateMD5(filePath string) (string, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\thash := md5.New()\n\tif _, err := io.Copy(hash, file); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn fmt.Sprintf(\"%x\", hash.Sum(nil)), nil\n}\n\n// updateMD5SumFile upserts the md5sum entry for a given file.\nfunc updateMD5SumFile(md5sumPath, filePath, md5 string) error {\n\t// Read existing content\n\tcontent, err := os.ReadFile(md5sumPath)\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn err\n\t}\n\n\t// Prepare new content\n\tnewLine := fmt.Sprintf(\"%s  %s\", md5, filePath)\n\tlines := []string{newLine}\n\tif len(content) > 0 {\n\t\texistingLines := strings.Split(string(content), \"\\n\")\n\t\tfor _, line := range existingLines {\n\t\t\tif line != \"\" && !strings.Contains(line, filePath) {\n\t\t\t\tlines = append(lines, line)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Write updated content\n\treturn os.WriteFile(md5sumPath, []byte(strings.Join(lines, \"\\n\")), 0644)\n}\n\nfunc addAutoinstallParameter(filePath string) error {\n\t// Skip if file does not exist\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\treturn nil // file not found, skip\n\t}\n\n\t// Read file content\n\tcontent, err := os.ReadFile(filePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Only inject if not already present\n\tif !bytes.Contains(content, []byte(AutoInstallKeyword)) {\n\t\t// Replace '---' with the injection string\n\t\tnewContent := bytes.Replace(content, []byte(GrubReplaceMarker), []byte(AutoInstallInject), -1)\n\t\tif err := os.WriteFile(filePath, newContent, DefaultFilePerm); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// UpdateMD5ForGrubFile updates or clears MD5 entries for grub files.\nfunc (gen *Generator) UpdateMD5ForGrubFile(codename string, md5CheckSum bool) error {\n\tmd5SumPath := gen.Path.MD5SumFile(MD5SumFile)\n\tgrubConfigPath := gen.Path.GrubConfigFile(GrubConfigPath)\n\tloopBackConfigPath := gen.Path.LoopBackConfigFile(LoopBackConfigPath)\n\n\tif md5CheckSum {\n\t\tlogger.Info(\"Updating md5sum.txt with hashes of modified files...\")\n\n\t\t// Calculate MD5 for grub.cfg\n\t\tgrubMD5, err := calculateMD5(grubConfigPath)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to calculate MD5 for grub.cfg: %w\", err)\n\t\t}\n\n\t\t// Update md5sum.txt entry for grub.cfg\n\t\tif err := updateMD5SumFile(md5SumPath, GrubConfigPath, grubMD5); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to update md5sum.txt for grub.cfg: %w\", err)\n\t\t}\n\n\t\t// For focal, also handle loopback.cfg\n\t\tif codename == \"focal\" {\n\t\t\tloopBackMD5, err := calculateMD5(loopBackConfigPath)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to calculate MD5 for loopback.cfg: %w\", err)\n\t\t\t}\n\t\t\tif err := updateMD5SumFile(md5SumPath, LoopBackConfigPath, loopBackMD5); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to update md5sum.txt for loopback.cfg: %w\", err)\n\t\t\t}\n\t\t}\n\t\tlogger.Info(\"Updated hashes\")\n\t} else {\n\t\tlogger.Info(\"Clearing MD5 hashes...\")\n\t\t// Ensure file exists before truncation\n\t\tif _, err := os.Stat(md5SumPath); os.IsNotExist(err) {\n\t\t\tif err := os.WriteFile(md5SumPath, []byte{}, 0644); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to create md5sum.txt: %w\", err)\n\t\t\t}\n\t\t}\n\t\tif err := os.Truncate(md5SumPath, 0); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to clear md5sum.txt: %w\", err)\n\t\t}\n\t\tlogger.Info(\"Cleared hashes\")\n\t}\n\n\treturn nil\n}\n\n// UpdateGrubMD5Sums is an alias for UpdateMD5ForGrubFile.\nfunc (gen *Generator) UpdateGrubMD5Sums(codename string, md5CheckSum bool) error {\n\treturn gen.UpdateMD5ForGrubFile(codename, md5CheckSum)\n}\n\n// AddAutoinstallParameterToKernel injects autoinstall into kernel command lines.\nfunc (gen *Generator) AddAutoinstallParameterToKernel(codename string) error {\n\tlogger.Info(\"Adding autoinstall parameter to kernel command line...\")\n\n\t// Paths to GRUB and related config files\n\tgrubConfigPath := gen.Path.GrubConfigFile(GrubConfigPath)\n\tloopBackConfigPath := gen.Path.LoopBackConfigFile(LoopBackConfigPath)\n\ttxtConfigPath := gen.Path.TxtConfigFile(TxtConfigPath)\n\n\tif err := addAutoinstallParameter(grubConfigPath); err != nil {\n\t\treturn fmt.Errorf(\"failed to modify grub.cfg: %w\", err)\n\t}\n\n\t// For focal, also update loopback.cfg and txt.cfg\n\tif codename == \"focal\" {\n\n\t\tif err := addAutoinstallParameter(loopBackConfigPath); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to modify loopback.cfg: %w\", err)\n\t\t}\n\n\t\tif err := addAutoinstallParameter(txtConfigPath); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to modify txt.cfg: %w\", err)\n\t\t}\n\t}\n\tlogger.Info(\"Added parameter to UEFI and BIOS kernel command lines\")\n\treturn nil\n}\n\n// AddAutoinstallKernelParams is an alias for AddAutoinstallParameterToKernel.\nfunc (gen *Generator) AddAutoinstallKernelParams(codename string) error {\n\treturn gen.AddAutoinstallParameterToKernel(codename)\n}\n\n// ConfigureHWEKernel switches to HWE kernel/initrd if available and requested.\nfunc (gen *Generator) ConfigureHWEKernel(codename string, useHWEKernel bool) error {\n\tif useHWEKernel {\n\t\tgrubConfigPath := gen.Path.GrubConfigFile(GrubConfigPath)\n\t\ttxtConfigPath := gen.Path.TxtConfigFile(TxtConfigPath)\n\t\tloopBackConfigPath := gen.Path.LoopBackConfigFile(LoopBackConfigPath)\n\t\t// Ensure HWE kernel is supported by the source ISO\n\t\tif _, err := os.Stat(grubConfigPath); os.IsNotExist(err) {\n\t\t\tlogger.Warn(\"This source ISO does not support the HWE kernel. Proceeding with the regular kernel\")\n\t\t\treturn nil\n\t\t}\n\n\t\t// Read grub.cfg contents\n\t\tcontent, err := os.ReadFile(grubConfigPath)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to read grub.cfg: %w\", err)\n\t\t}\n\t\tif !bytes.Contains(content, []byte(\"hwe-vmlinuz\")) {\n\t\t\tlogger.Warn(\"This source ISO does not support the HWE kernel. Proceeding with the regular kernel\")\n\t\t\treturn nil\n\t\t}\n\n\t\tlogger.Info(\"Destination ISO will use HWE kernel\")\n\n\t\t// Replace kernel and initrd paths with HWE counterparts\n\n\t\tnewContent := bytes.Replace(content, []byte(KernelFile), []byte(HWEKernelFile), -1)\n\t\tnewContent = bytes.Replace(newContent, []byte(InitrdFile), []byte(HWEInitrdFile), -1)\n\n\t\tif err := os.WriteFile(grubConfigPath, newContent, 0644); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to update grub.cfg: %w\", err)\n\t\t}\n\n\t\t// For focal, also update txt.cfg and loopback.cfg\n\t\tif codename == \"focal\" {\n\t\t\tif err := updateHWEConfig(txtConfigPath); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to update txt.cfg: %w\", err)\n\t\t\t}\n\t\t\tif err := updateHWEConfig(loopBackConfigPath); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to update loopback.cfg: %w\", err)\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// updateHWEConfig updates kernel/initrd paths in the target file for HWE.\nfunc updateHWEConfig(filePath string) error {\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\treturn nil\n\t}\n\n\tcontent, err := os.ReadFile(filePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tnewContent := bytes.Replace(content, []byte(KernelFile), []byte(HWEKernelFile), -1)\n\tnewContent = bytes.Replace(newContent, []byte(InitrdFile), []byte(HWEInitrdFile), -1)\n\treturn os.WriteFile(filePath, newContent, 0644)\n}\n\n// Cleanup removes temporary files and directories.\nfunc (gen *Generator) Cleanup() error {\n\treturn os.RemoveAll(gen.Path.RootDir)\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/generator/generator.go b/generator/generator.go
--- a/generator/generator.go	(revision 294a6fba5e1264cf155a490602da6f1d1cb5f19d)
+++ b/generator/generator.go	(date 1758249652956)
@@ -717,78 +717,6 @@
 	return f.Close()
 }
 
-//func modifyGrubConfig(path string) error {
-//	// Check if file exists
-//	if _, err := os.Stat(path); os.IsNotExist(err) {
-//		return nil // Skip if file does not exist
-//	} else if err != nil {
-//		return fmt.Errorf("failed to stat file %s: %w", filepath.Base(path), err)
-//	}
-//
-//	// Read file content
-//	content, err := os.ReadFile(path)
-//	if err != nil {
-//		return fmt.Errorf("failed to read file %s: %w", filepath.Base(path), err)
-//	}
-//
-//	// Split content into lines
-//	lines := strings.Split(string(content), "\n")
-//	modified := false
-//
-//	for i, line := range lines {
-//		// Trim whitespace from the beginning to handle leading spaces
-//		trimmedLine := strings.TrimLeft(line, " \t")
-//		if trimmedLine == "" {
-//			continue
-//		}
-//
-//		// Handle "append" or "linux" lines ending with "---"
-//		if (strings.HasPrefix(trimmedLine, "append") || strings.HasPrefix(trimmedLine, "linux")) && strings.HasSuffix(line, "---") {
-//			// Check if autoinstall is already present
-//			if !strings.Contains(line, "autoinstall") {
-//				// Remove trailing "---" temporarily
-//				baseLine := strings.TrimSuffix(line, "---")
-//				// Find the position after "quiet"
-//				parts := strings.Fields(baseLine) // Split into words
-//				var newParts []string
-//				quietFound := false
-//
-//				for _, part := range parts {
-//					newParts = append(newParts, part)
-//					if part == "quiet" {
-//						quietFound = true
-//						// Insert autoinstall params after "quiet"
-//						newParts = append(newParts, GrubInsertText)
-//					}
-//				}
-//
-//				// If "quiet" is not found, append at the end
-//				if !quietFound && len(parts) > 0 {
-//					newParts = append(newParts, GrubInsertText)
-//				}
-//
-//				// Reconstruct the line with "---"
-//				newLine := strings.Join(newParts, " ") + " ---"
-//				lines[i] = newLine
-//				modified = true
-//			}
-//		}
-//	}
-//
-//	// If no modification, return early
-//	if !modified {
-//		return nil
-//	}
-//
-//	// Join lines back and write to file
-//	newContent := []byte(strings.Join(lines, "\n"))
-//	if err := os.WriteFile(path, newContent, GrubFilePerm); err != nil {
-//		return fmt.Errorf("failed to write file %s: %w", filepath.Base(path), err)
-//	}
-//
-//	return nil
-//}
-
 func patchLine(line string) string {
 	trim := strings.TrimSpace(line)
 
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"AutoImportSettings\">\n    <option name=\"autoReloadType\" value=\"ALL\" />\n  </component>\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"019696e3-38c5-45ef-9a37-8af64e6a16bd\" name=\"更改\" comment=\"v1\">\n      <change afterPath=\"$PROJECT_DIR$/build/build.sh\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/test/test.go\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/test/test_test.go\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/README.md\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/README.md\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/generator/consts.go\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/generator/consts.go\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/generator/generator.go\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/generator/generator.go\" afterDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"FileTemplateManagerImpl\">\n    <option name=\"RECENT_TEMPLATES\">\n      <list>\n        <option value=\"Go File\" />\n      </list>\n    </option>\n  </component>\n  <component name=\"GOROOT\" url=\"file://$PROJECT_DIR$/../../go1.24.7\" />\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n  </component>\n  <component name=\"GitHubPullRequestSearchHistory\">{\n  &quot;lastFilter&quot;: {\n    &quot;state&quot;: &quot;OPEN&quot;,\n    &quot;assignee&quot;: &quot;lefeck&quot;\n  }\n}</component>\n  <component name=\"GithubPullRequestsUISettings\">{\n  &quot;selectedUrlAndAccountId&quot;: {\n    &quot;url&quot;: &quot;https://github.com/lefeck/autouiso.git&quot;,\n    &quot;accountId&quot;: &quot;9716bc94-79ad-4cc2-a1bb-f95b07bb098e&quot;\n  }\n}</component>\n  <component name=\"GoLibraries\">\n    <option name=\"indexEntireGoPath\" value=\"true\" />\n  </component>\n  <component name=\"KubernetesApiPersistence\">{}</component>\n  <component name=\"KubernetesApiProvider\">{\n  &quot;isMigrated&quot;: true\n}</component>\n  <component name=\"ProjectColorInfo\">{\n  &quot;associatedIndex&quot;: 6\n}</component>\n  <component name=\"ProjectId\" id=\"31K6MLjuNPTRcB0If0Il81CRYzP\" />\n  <component name=\"ProjectLevelVcsManager\">\n    <ConfirmationsSetting value=\"2\" id=\"Add\" />\n  </component>\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"openDirectoriesWithSingleClick\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\"><![CDATA[{\n  \"keyToString\": {\n    \"ASKED_SHARE_PROJECT_CONFIGURATION_FILES\": \"true\",\n    \"DefaultGoTemplateProperty\": \"Go File\",\n    \"Go 测试.autouiso/cmd 中的 TestRunCmd_StringCommand.executor\": \"Run\",\n    \"Go 测试.github.com/lefeck/autouiso/test 中的 TestModifyBootConfig.executor\": \"Run\",\n    \"Go 测试.tmp_test.go.executor\": \"Run\",\n    \"ModuleVcsDetector.initialDetectionPerformed\": \"true\",\n    \"RunOnceActivity.GoLinterPluginOnboarding\": \"true\",\n    \"RunOnceActivity.GoLinterPluginStorageMigration\": \"true\",\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\n    \"RunOnceActivity.git.unshallow\": \"true\",\n    \"RunOnceActivity.go.formatter.settings.were.checked\": \"true\",\n    \"RunOnceActivity.go.migrated.go.modules.settings\": \"true\",\n    \"RunOnceActivity.go.modules.go.list.on.any.changes.was.set\": \"true\",\n    \"git-widget-placeholder\": \"main\",\n    \"go.import.settings.migrated\": \"true\",\n    \"go.sdk.automatically.set\": \"true\",\n    \"last_opened_file_path\": \"/Users/Johnny/go/src/autouiso/build\",\n    \"node.js.detected.package.eslint\": \"true\",\n    \"node.js.selected.package.eslint\": \"(autodetect)\",\n    \"nodejs_package_manager_path\": \"npm\",\n    \"settings.editor.selected.configurable\": \"go.vgo\",\n    \"vue.rearranger.settings.migration\": \"true\"\n  }\n}]]></component>\n  <component name=\"RecentsManager\">\n    <key name=\"CopyFile.RECENT_KEYS\">\n      <recent name=\"$PROJECT_DIR$/build\" />\n    </key>\n    <key name=\"MoveFile.RECENT_KEYS\">\n      <recent name=\"$PROJECT_DIR$\" />\n      <recent name=\"$PROJECT_DIR$/doc\" />\n      <recent name=\"$PROJECT_DIR$/config\" />\n      <recent name=\"$PROJECT_DIR$/server\" />\n    </key>\n  </component>\n  <component name=\"RunManager\" selected=\"Go 测试.github.com/lefeck/autouiso/test 中的 TestModifyBootConfig\">\n    <configuration default=\"true\" type=\"GoApplicationRunConfiguration\" factoryName=\"Go Application\">\n      <module name=\"autouiso\" />\n      <working_directory value=\"$PROJECT_DIR$\" />\n      <go_parameters value=\"-i\" />\n      <kind value=\"PACKAGE\" />\n      <package value=\"autouiso\" />\n      <directory value=\"$PROJECT_DIR$\" />\n      <filePath value=\"$PROJECT_DIR$\" />\n      <method v=\"2\" />\n    </configuration>\n    <configuration name=\"go build cmd.go\" type=\"GoApplicationRunConfiguration\" factoryName=\"Go Application\" temporary=\"true\" nameIsGenerated=\"true\">\n      <module name=\"autouiso\" />\n      <working_directory value=\"$PROJECT_DIR$\" />\n      <kind value=\"FILE\" />\n      <package value=\"autouiso\" />\n      <directory value=\"$PROJECT_DIR$\" />\n      <filePath value=\"$PROJECT_DIR$/cmd/cmd.go\" />\n      <method v=\"2\" />\n    </configuration>\n    <configuration default=\"true\" type=\"GoTestRunConfiguration\" factoryName=\"Go Test\">\n      <module name=\"autouiso\" />\n      <working_directory value=\"$PROJECT_DIR$\" />\n      <go_parameters value=\"-i\" />\n      <kind value=\"DIRECTORY\" />\n      <directory value=\"$PROJECT_DIR$\" />\n      <filePath value=\"$PROJECT_DIR$\" />\n      <framework value=\"gotest\" />\n      <method v=\"2\" />\n    </configuration>\n    <configuration name=\"autouiso/cmd 中的 TestRunCmd_StringCommand\" type=\"GoTestRunConfiguration\" factoryName=\"Go Test\" temporary=\"true\" nameIsGenerated=\"true\">\n      <module name=\"autouiso\" />\n      <working_directory value=\"$PROJECT_DIR$/cmd\" />\n      <root_directory value=\"$PROJECT_DIR$\" />\n      <kind value=\"PACKAGE\" />\n      <package value=\"autouiso/cmd\" />\n      <directory value=\"$PROJECT_DIR$\" />\n      <filePath value=\"$PROJECT_DIR$\" />\n      <framework value=\"gotest\" />\n      <pattern value=\"^\\QTestRunCmd_StringCommand\\E$\" />\n      <method v=\"2\" />\n    </configuration>\n    <configuration name=\"github.com/lefeck/autouiso/test 中的 TestModifyBootConfig\" type=\"GoTestRunConfiguration\" factoryName=\"Go Test\" temporary=\"true\" nameIsGenerated=\"true\">\n      <module name=\"autouiso\" />\n      <working_directory value=\"$PROJECT_DIR$/test\" />\n      <root_directory value=\"$PROJECT_DIR$\" />\n      <kind value=\"PACKAGE\" />\n      <package value=\"github.com/lefeck/autouiso/test\" />\n      <directory value=\"$PROJECT_DIR$\" />\n      <filePath value=\"$PROJECT_DIR$\" />\n      <framework value=\"gotest\" />\n      <pattern value=\"^\\QTestModifyBootConfig\\E$\" />\n      <method v=\"2\" />\n    </configuration>\n    <configuration name=\"tmp_test.go\" type=\"GoTestRunConfiguration\" factoryName=\"Go Test\" temporary=\"true\" nameIsGenerated=\"true\">\n      <module name=\"autouiso\" />\n      <working_directory value=\"$PROJECT_DIR$/tmp\" />\n      <root_directory value=\"$PROJECT_DIR$\" />\n      <kind value=\"FILE\" />\n      <directory value=\"$PROJECT_DIR$\" />\n      <filePath value=\"$PROJECT_DIR$/tmp/tmp_test.go\" />\n      <framework value=\"gotest\" />\n      <method v=\"2\" />\n    </configuration>\n    <recent_temporary>\n      <list>\n        <item itemvalue=\"Go 测试.github.com/lefeck/autouiso/test 中的 TestModifyBootConfig\" />\n      </list>\n    </recent_temporary>\n  </component>\n  <component name=\"SharedIndexes\">\n    <attachedChunks>\n      <set>\n        <option value=\"bundled-gosdk-3b128438d3f6-07d2d2d66b1e-org.jetbrains.plugins.go.sharedIndexes.bundled-GO-251.27812.54\" />\n        <option value=\"bundled-js-predefined-d6986cc7102b-09060db00ec0-JavaScript-GO-251.27812.54\" />\n      </set>\n    </attachedChunks>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"应用程序级\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"默认任务\">\n      <changelist id=\"019696e3-38c5-45ef-9a37-8af64e6a16bd\" name=\"更改\" comment=\"\" />\n      <created>1755260367837</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1755260367837</updated>\n    </task>\n    <servers />\n  </component>\n  <component name=\"TypeScriptGeneratedFilesManager\">\n    <option name=\"version\" value=\"3\" />\n  </component>\n  <component name=\"Vcs.Log.Tabs.Properties\">\n    <option name=\"TAB_STATES\">\n      <map>\n        <entry key=\"MAIN\">\n          <value>\n            <State>\n              <option name=\"FILTERS\">\n                <map>\n                  <entry key=\"branch\">\n                    <value>\n                      <list>\n                        <option value=\"origin/main\" />\n                      </list>\n                    </value>\n                  </entry>\n                </map>\n              </option>\n            </State>\n          </value>\n        </entry>\n      </map>\n    </option>\n  </component>\n  <component name=\"VcsManagerConfiguration\">\n    <MESSAGE value=\"v1\" />\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"v1\" />\n  </component>\n  <component name=\"VgoProject\">\n    <settings-migrated>true</settings-migrated>\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 294a6fba5e1264cf155a490602da6f1d1cb5f19d)
+++ b/.idea/workspace.xml	(date 1758249653070)
@@ -4,13 +4,7 @@
     <option name="autoReloadType" value="ALL" />
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="019696e3-38c5-45ef-9a37-8af64e6a16bd" name="更改" comment="v1">
-      <change afterPath="$PROJECT_DIR$/build/build.sh" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/test/test.go" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/test/test_test.go" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/README.md" beforeDir="false" afterPath="$PROJECT_DIR$/README.md" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/generator/consts.go" beforeDir="false" afterPath="$PROJECT_DIR$/generator/consts.go" afterDir="false" />
+    <list default="true" id="019696e3-38c5-45ef-9a37-8af64e6a16bd" name="更改" comment="Merge remote-tracking branch 'origin/main'">
       <change beforePath="$PROJECT_DIR$/generator/generator.go" beforeDir="false" afterPath="$PROJECT_DIR$/generator/generator.go" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
@@ -27,6 +21,11 @@
   </component>
   <component name="GOROOT" url="file://$PROJECT_DIR$/../../go1.24.7" />
   <component name="Git.Settings">
+    <option name="PREVIOUS_COMMIT_AUTHORS">
+      <list>
+        <option value="johnny &lt;jw6759792@gmail.com&gt;" />
+      </list>
+    </option>
     <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
   </component>
   <component name="GitHubPullRequestSearchHistory">{
@@ -214,7 +213,9 @@
   </component>
   <component name="VcsManagerConfiguration">
     <MESSAGE value="v1" />
-    <option name="LAST_COMMIT_MESSAGE" value="v1" />
+    <MESSAGE value="Update documentation description" />
+    <MESSAGE value="Merge remote-tracking branch 'origin/main'" />
+    <option name="LAST_COMMIT_MESSAGE" value="Merge remote-tracking branch 'origin/main'" />
   </component>
   <component name="VgoProject">
     <settings-migrated>true</settings-migrated>
